<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>eCorsi (forward) – fija</title>
  <style>
    :root{
      --bg:#0b0b0f;
      --text:#eaeaf2;
      --muted:#a6a6b3;
      --frame:#f0d64a;
      --flash:#ffe86a;
      --tap:#fff3a8;
      --blue:#4aa3ff;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
      min-height:100svh;
      display:flex;
      flex-direction:column;
    }
    header{
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .left{display:flex;flex-direction:column;gap:2px;min-width:0}
    .title{
      font-weight:800;font-size:14px;letter-spacing:.2px;
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
    }
    .status{
      font-size:13px;color:var(--muted);
      font-variant-numeric: tabular-nums;
      font-feature-settings:"tnum" 1;
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
    }
    .lamp{
      width:12px;height:12px;border-radius:50%;
      background:rgba(74,163,255,.14);
      border:1px solid rgba(74,163,255,.35);
      box-shadow:none;
      flex:0 0 auto;
    }
    .lamp.on{
      background:var(--blue);
      border-color:rgba(74,163,255,.95);
      box-shadow:0 0 18px rgba(74,163,255,.75);
    }

    main{
      flex:1;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      padding:10px;
      gap:10px;
    }

    #boardWrap{
      width:min(96vw, 760px);
      height:min(78svh, 560px);
      position:relative;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:#000;
      overflow:hidden;
      touch-action: manipulation;
    }
    #boardInner{
      position:absolute;
      inset:0;
    }

    .block{
      position:absolute;
      border:3px solid var(--frame);
      border-radius:10px;
      background:transparent;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }
    .block.flash{ background:var(--flash); }
    .block.tapped{ background:var(--tap); }

    /* Overlay centrado (Siguiente, FIN, etc.) */
    #overlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:18px;
      background:rgba(0,0,0,.35);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      font-weight:900;
      font-size: clamp(22px, 5vw, 44px);
      letter-spacing:.6px;
    }
    #overlay.show{ display:flex; }

    .panel{
      width:min(96vw, 760px);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      flex-wrap:wrap;
    }
    button{
      padding:10px 12px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:var(--text);
      font-weight:800;
    }
    button:disabled{opacity:.45}
    .hint{
      font-size:12px;color:var(--muted);line-height:1.25;
      max-width:70ch;
    }
  </style>
</head>
<body>
<header>
  <div class="left">
    <div class="title">eCorsi – forward (secuencia fija)</div>
    <div class="status" id="statusLine">Ensayo: – | Span actual: –</div>
  </div>
  <div class="lamp" id="lamp" title="Luz azul: puedes responder"></div>
</header>

<main>
  <div id="boardWrap" aria-label="Tablero eCorsi">
    <div id="boardInner"></div>
    <div id="overlay"></div>
  </div>

  <div class="panel">
    <button id="btnStart">Empezar</button>
    <button id="btnReset">Reset</button>
    <div class="hint" id="hint">Observa la secuencia y luego toca los bloques en el mismo orden.</div>
  </div>
</main>

<script>
(() => {
  // --- Timings del artículo ---
  const FLASH_MS = 500;
  const IOI_MS = 1000;

  // --- Buffers / pauses ---
  // Pausa tras responder antes de mostrar "Siguiente" (para evitar doble tap residual)
  const POST_RESPONSE_BUFFER_MS = 250;
  // Tiempo que permanece "Siguiente" en pantalla antes del inicio del próximo ensayo (lo que pides)
  const NEXT_OVERLAY_MS = 1200;

  // --- Layout lógico (datasheet) ---
  const CANVAS_W = 1020;
  const CANVAS_H = 820;
  const BLOCK_SIZE = 120;

  // Coordenadas finales del datasheet (vista del sujeto). IDs 1..9
  const BLOCKS = [
    {id:1, x:353, y:574},
    {id:2, x:753, y:534},
    {id:3, x:153, y:444},
    {id:4, x:603, y:394},
    {id:5, x:313, y:314},
    {id:6, x:103, y:194},
    {id:7, x:813, y:154},
    {id:8, x:573, y:34},
    {id:9, x:333, y:74},
  ];

  // Secuencias fijas forward: 2 por longitud (datasheet). IDs 1..9
  const FIXED_FORWARD = {
    2:  [[4,7],[2,9]],
    3:  [[9,3,4],[6,3,7]],
    4:  [[1,5,2,8],[7,4,3,9]],
    5:  [[3,1,8,6,5],[9,3,1,4,7]],
    6:  [[2,8,3,5,6,4],[5,3,1,2,8,9]],
    7:  [[7,3,2,9,1,8,6],[4,3,7,6,2,5,9]],
    8:  [[1,9,6,3,5,4,2,8],[2,9,4,6,1,7,3,5]],
    9:  [[5,3,8,7,1,2,4,6,9],[4,2,6,8,1,7,9,3,5]],
  };

  const MIN_LEN = 2;
  const MAX_LEN = 9;
  const TRIALS_PER_LEN = 2;

  // --- DOM ---
  const boardWrap = document.getElementById('boardWrap');
  const boardInner = document.getElementById('boardInner');
  const overlay = document.getElementById('overlay');

  const btnStart = document.getElementById('btnStart');
  const btnReset = document.getElementById('btnReset');
  const statusLine = document.getElementById('statusLine');
  const lamp = document.getElementById('lamp');
  const hint = document.getElementById('hint');

  // --- Estado ---
  let blockEls = [];
  let running = false;

  // state machine
  // "idle" | "presenting" | "responding" | "between" | "finished"
  let state = "idle";

  let curLen = MIN_LEN;
  let trialInLen = 0; // 0..1
  let attemptN = 0;

  let currentSeqIdx = [];
  let respSeqIdx = [];

  let bestSpan = 0;
  let totalCorrect = 0;
  let correctThisLen = 0;

  // --- Helpers ---
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  function setLamp(on){ lamp.classList.toggle('on', !!on); }

  function showOverlay(text){
    overlay.textContent = text;
    overlay.classList.add('show');
  }
  function hideOverlay(){
    overlay.textContent = "";
    overlay.classList.remove('show');
  }

  function setStatus(){
    const spanTxt = bestSpan ? String(bestSpan) : "–";
    const attemptTxt = attemptN ? String(attemptN) : "–";
    statusLine.textContent = `Ensayo: ${attemptTxt} | Span actual: ${spanTxt}`;
  }

  function clearVisuals(){
    for (const el of blockEls){
      el.classList.remove('flash');
      el.classList.remove('tapped');
    }
  }

  function idsToIdx(seqIDs){
    return seqIDs.map(id => {
      const idx = BLOCKS.findIndex(b => b.id === id);
      if (idx < 0) throw new Error("ID de bloque no encontrado: " + id);
      return idx;
    });
  }

  function arraysEqual(a,b){
    if (a.length !== b.length) return false;
    for (let i=0;i<a.length;i++) if (a[i] !== b[i]) return false;
    return true;
  }

  function getFixedSeqIdx(len, which){
    const seqIDs = FIXED_FORWARD[len][which]; // which = 0/1
    return idsToIdx(seqIDs);
  }

  // --- Render + responsive ---
  function renderBlocks(){
    boardInner.innerHTML = "";
    blockEls = BLOCKS.map((b, idx) => {
      const el = document.createElement('div');
      el.className = "block";
      el.dataset.idx = String(idx);
      // pointerup suele ser más estable en móvil para tareas de tapping
      el.addEventListener('pointerup', onTap);
      boardInner.appendChild(el);
      return el;
    });
    layoutBlocks();
  }

  function layoutBlocks(){
    const W = boardWrap.clientWidth;
    const H = boardWrap.clientHeight;
    const scale = Math.min(W / CANVAS_W, H / CANVAS_H);
    const usedW = CANVAS_W * scale;
    const usedH = CANVAS_H * scale;
    const offsetX = (W - usedW) / 2;
    const offsetY = (H - usedH) / 2;

    for (let i=0;i<BLOCKS.length;i++){
      const b = BLOCKS[i];
      const el = blockEls[i];
      el.style.left = (offsetX + b.x * scale) + "px";
      el.style.top  = (offsetY + b.y * scale) + "px";
      el.style.width  = (BLOCK_SIZE * scale) + "px";
      el.style.height = (BLOCK_SIZE * scale) + "px";
    }
  }

  const ro = new ResizeObserver(layoutBlocks);
  ro.observe(boardWrap);

  // --- Presentación (flash) ---
  async function presentSequence(seqIdx){
    state = "presenting";
    setLamp(false);
    hideOverlay();
    clearVisuals();

    for (let k=0;k<seqIdx.length;k++){
      const idx = seqIdx[k];
      blockEls[idx].classList.add('flash');
      await sleep(FLASH_MS);
      blockEls[idx].classList.remove('flash');

      const gap = Math.max(0, IOI_MS - FLASH_MS);
      if (k < seqIdx.length - 1) await sleep(gap);
    }

    // luz azul: puede responder
    setLamp(true);
    state = "responding";
    respSeqIdx = [];
  }

  // --- Respuesta ---
  function onTap(e){
    if (!running || state !== "responding") return;

    const idx = Number(e.currentTarget.dataset.idx);
    respSeqIdx.push(idx);

    // confirmación breve del toque (no queda marcado)
    const el = e.currentTarget;
    el.classList.add('tapped');
    setTimeout(() => el.classList.remove('tapped'), 120);

    if (respSeqIdx.length === currentSeqIdx.length){
      setLamp(false);
      state = "between";
      void scoreAndAdvance();
    }
  }

  // --- Entre ensayos: mostrar "Siguiente" SIEMPRE ---
  async function showNextAndContinue(){
    showOverlay("SIGUIENTE");
    await sleep(NEXT_OVERLAY_MS);
    hideOverlay();
  }

  // --- Score + lógica span ---
  async function scoreAndAdvance(){
    const ok = arraysEqual(respSeqIdx, currentSeqIdx);
    if (ok){
      totalCorrect += 1;
      correctThisLen += 1;
      bestSpan = Math.max(bestSpan, curLen);
    }
    setStatus();

    // buffer corto post-respuesta
    await sleep(POST_RESPONSE_BUFFER_MS);

    // mensaje “Siguiente” con pausa (lo que pides)
    await showNextAndContinue();

    // avanzar intento
    trialInLen += 1;

    if (trialInLen < TRIALS_PER_LEN){
      await nextTrial();
      return;
    }

    // fin de longitud
    if (correctThisLen >= 1){
      curLen += 1;
      trialInLen = 0;
      correctThisLen = 0;

      if (curLen > MAX_LEN){
        finish();
      } else {
        await nextTrial();
      }
    } else {
      finish();
    }
  }

  async function nextTrial(){
    attemptN += 1;
    setStatus();

    // secuencia fija por longitud, selector por trialInLen (0/1)
    currentSeqIdx = getFixedSeqIdx(curLen, trialInLen);

    await presentSequence(currentSeqIdx);
  }

  function finish(){
    running = false;
    state = "finished";
    setLamp(false);
    btnStart.disabled = false;

    showOverlay(`FIN\n\nSPAN = ${bestSpan || 0}\nACIERTOS = ${totalCorrect}`);
    hint.textContent = "Fin de la tarea.";
    setStatus();
  }

  function resetAll(){
    running = false;
    state = "idle";
    setLamp(false);
    btnStart.disabled = false;

    curLen = MIN_LEN;
    trialInLen = 0;
    attemptN = 0;
    currentSeqIdx = [];
    respSeqIdx = [];

    bestSpan = 0;
    totalCorrect = 0;
    correctThisLen = 0;

    hideOverlay();
    clearVisuals();
    hint.textContent = "Observa la secuencia y luego toca los bloques en el mismo orden.";
    setStatus();
  }

  async function start(){
    resetAll();
    running = true;
    btnStart.disabled = true;

    // pequeño “ready” opcional antes del primer ensayo (puedes quitarlo si no lo quieres)
    await showNextAndContinue();

    await nextTrial();
  }

  // init
  renderBlocks();
  setStatus();

  btnStart.addEventListener('click', () => void start());
  btnReset.addEventListener('click', resetAll);
})();
</script>
</body>
</html>
