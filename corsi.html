<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>eCorsi (forward) – demo fija</title>
  <style>
    :root{
      --bg:#0b0b0f;
      --text:#eaeaf2;
      --muted:#a6a6b3;
      --frame:#f0d64a;
      --flash:#ffe86a;
      --tap:#fff3a8;
      --blue:#4aa3ff;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
      min-height:100svh;
      display:flex;
      flex-direction:column;
    }
    header{
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .left{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width:0;
    }
    .title{
      font-weight:800;
      font-size:14px;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .status{
      font-size:13px;
      color:var(--muted);
      font-variant-numeric: tabular-nums;
      font-feature-settings:"tnum" 1;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .lamp{
      width:12px;height:12px;border-radius:50%;
      background:rgba(74,163,255,.14);
      border:1px solid rgba(74,163,255,.35);
      box-shadow:none;
      flex:0 0 auto;
    }
    .lamp.on{
      background:var(--blue);
      border-color:rgba(74,163,255,.95);
      box-shadow:0 0 18px rgba(74,163,255,.75);
    }

    main{
      flex:1;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      padding:10px;
      gap:10px;
    }

    /* contenedor que funciona bien en vertical u horizontal */
    #boardWrap{
      width:min(96vw, 720px);
      height:min(78svh, 520px);
      position:relative;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:#000;
      overflow:hidden;
      touch-action: manipulation; /* evita zoom/scroll por doble tap */
    }

    /* "inner" es el canvas lógico 1020x820 escalado/centrado */
    #boardInner{
      position:absolute;
      left:0; top:0;
      width:100%; height:100%;
    }

    .block{
      position:absolute;
      border:3px solid var(--frame);
      border-radius:10px;
      background:transparent;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .block.flash{ background:var(--flash); }
    .block.tapped{ background:var(--tap); }

    .panel{
      width:min(96vw, 720px);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      flex-wrap:wrap;
    }
    button{
      padding:10px 12px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:var(--text);
      font-weight:700;
    }
    button:disabled{opacity:.45}
    .hint{
      font-size:12px;
      color:var(--muted);
      line-height:1.25;
      max-width:60ch;
    }
  </style>
</head>
<body>
<header>
  <div class="left">
    <div class="title">eCorsi – forward (secuencia fija)</div>
    <div class="status" id="statusLine">Ensayo: – | Span actual: –</div>
  </div>
  <div class="lamp" id="lamp" title="Luz azul: puedes responder"></div>
</header>

<main>
  <div id="boardWrap" aria-label="Tablero eCorsi">
    <div id="boardInner"></div>
  </div>

  <div class="panel">
    <button id="btnStart">Empezar</button>
    <button id="btnReset">Reset</button>
    <div class="hint" id="hint">
      Toca los bloques en el mismo orden. (No se muestran secuencias.)
    </div>
  </div>
</main>

<script>
(() => {
  // =============================
  // Timings del artículo eCorsi:
  // flash = 500 ms; Inter-Onset Interval = 1000 ms; luz azul al final. :contentReference[oaicite:5]{index=5}
  // =============================
  const FLASH_MS = 500;
  const IOI_MS = 1000;

  // El artículo no especifica un ITI fijo: aquí ponemos un buffer mínimo para evitar taps residuales.
  const ITI_AFTER_RESPONSE_MS = 700;

  // =============================
  // Layout (datasheet): canvas lógico 1020x820, bloques 120x120,
  // coordenadas finales (vista del sujeto; ya "flip" aplicado). :contentReference[oaicite:6]{index=6}
  // =============================
  const CANVAS_W = 1020;
  const CANVAS_H = 820;
  const BLOCK_SIZE = 120;

  // Bloques numerados 1..9 en el datasheet. Aquí usamos índice 0..8.
  const BLOCKS = [
    {id:1,:contentReference[oaicite:7]{index=7}id:2, x:753, y:534},
    {id:3, x:153, y:444},
    {id:4, x:603, y:394},
    {id:5, x:313, y:314},
    {id:6, x:103, y:194},
    {id:7, x:813, y:154},
    {id:8, x:573, y:34},
    {id:9, x:333, y:74},
  ];

  // =============================
  // Secuencias fijas (forward) del datasheet (2 por longitud). :contentReference[oaicite:8]{index=8}
  // OJO: en el datasheet están en IDs 1..9. Aquí convertimos a índices 0..8.
  // =============================
  const FIXED_FORWARD = {
    2:  [[4,7],[2,9]],
    3:  [[9,3,4],[6,3,7]],
    4:  [[1,5,2,8],[7:contentReference[oaicite:9]{index=9},1,8,6,5],[9,3,1,4,7]],
    6:  [[2,8,3,5,6,4],[5,3,1,2,8,9]],
    7:  [[7,3,2,9,1,8,6],[4,3,7,6,2,5,9]],
    8:  [[1,9,6,3,5,4,2,8],[2,9,4,6,1,7,3,5]],
    9:  [[5,3,8,7,1,2,4,6,9],[4,2,6,8,1,7,9,3,5]],
  };

  const MIN_LEN = 2;
  const MAX_LEN = 9;
  const TRIALS_PER_LEN = 2;

  // =============================
  // DOM
  // =============================
  const boardWrap = document.getElementById('boardWrap');
  const boardInner = document.getElementById('boardInner');
  const btnStart = document.getElementById('btnStart');
  const btnReset = document.getElementById('btnReset');
  const statusLine = document.getElementById('statusLine');
  const lamp = document.getElementById('lamp');
  const hint = document.getElementById('hint');

  // =============================
  // Estado
  // =============================
  let blockEls = [];       // index 0..8
  let running = false;
  let accepting = false;

  let curLen = MIN_LEN;
  let trialInLen = 0;      // 0..1
  let attemptN = 0;

  let currentSeqIdx = [];  // índices 0..8
  let respSeqIdx = [];

  let bestSpan = 0;
  let totalCorrect = 0;
  let correctThisLen = 0;

  // =============================
  // Helpers
  // =============================
  function setLamp(on){ lamp.classList.toggle('on', !!on); }
  function setStatus(){
    const spanTxt = bestSpan ? String(bestSpan) : "–";
    const attemptTxt = attemptN ? String(attemptN) : "–";
    statusLine.textContent = `Ensayo: ${attemptTxt} | Span actual: ${spanTxt}`;
  }
  function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

  function idsToIdx(seqIDs){
    return seqIDs.map(id => {
      const idx = BLOCKS.findIndex(b => b.id === id);
      if (idx < 0) throw new Error("ID de bloque no encontrado: " + id);
      return idx;
    });
  }

  function arraysEqual(a,b){
    if (a.length !== b.length) return false;
    for (let i=0;i<a.length;i++) if (a[i] !== b[i]) return false;
    return true;
  }

  // =============================
  // Render + Responsive layout (vertical/horizontal)
  // =============================
  function renderBlocks(){
    boardInner.innerHTML = "";
    blockEls = BLOCKS.map((b, idx) => {
      const el = document.createElement('div');
      el.className = "block";
      el.dataset.idx = String(idx);
      el.addEventListener('pointerdown', onTap, {passive:true});
      boardInner.appendChild(el);
      return el;
    });
    layoutBlocks(); // primera colocación
  }

  function layoutBlocks(){
    // Escala el canvas lógico 1020x820 dentro del contenedor real, manteniendo aspecto,
    // y centra (offsetX/offsetY).
    const W = boardWrap.clientWidth;
    const H = boardWrap.clientHeight;

    const scale = Math.min(W / CANVAS_W, H / CANVAS_H);
    const usedW = CANVAS_W * scale;
    const usedH = CANVAS_H * scale;
    const offsetX = (W - usedW) / 2;
    const offsetY = (H - usedH) / 2;

    for (let i=0;i<BLOCKS.length;i++){
      const b = BLOCKS[i];
      const el = blockEls[i];
      el.style.left = (offsetX + b.x * scale) + "px";
      el.style.top  = (offsetY + b.y * scale) + "px";
      el.style.width = (BLOCK_SIZE * scale) + "px";
      el.style.height = (BLOCK_SIZE * scale) + "px";
    }
  }

  // Re-layout al rotar / resize (vertical/horizontal)
  const ro = new ResizeObserver(() => layoutBlocks());
  ro.observe(boardWrap);

  // =============================
  // Presentación de secuencia
  // =============================
  async function flashSequence(seqIdx){
    accepting = false;
    setLamp(false);
    clearVisuals();

    // Presentación: cada flash 500ms, IOI=1000ms (=> gap 500ms). :contentReference[oaicite:10]{index=10}
    for (let k=0;k<seqIdx.length;k++){
      const idx = seqIdx[k];
      blockEls[idx].classList.add('flash');
      await sleep(FLASH_MS);
      blockEls[idx].classList.remove('flash');

      const gap = Math.max(0, IOI_MS - FLASH_MS);
      if (k < seqIdx.length - 1) await sleep(gap);
    }

    // Al acabar la secuencia, luz azul indica "puedes responder". :contentReference[oaicite:11]{index=11}
    setLamp(true);
    accepting = true;
    respSeqIdx = [];
  }

  function clearVisuals(){
    for (const el of blockEls){
      el.classList.remove('flash');
      el.classList.remove('tapped');
    }
  }

  // =============================
  // Respuesta
  // =============================
  function onTap(e){
    if (!running || !accepting) return;

    const idx = Number(e.currentTarget.dataset.idx);
    respSeqIdx.push(idx);

    // Confirmación breve de toque (el artículo dice que se iluminan para confirmar detección,
    // no especifica que queden marcados). :contentReference[oaicite:12]{index=12}
    e.currentTarget.classList.add('tapped');
    setTimeout(() => e.currentTarget.classList.remove('tapped'), 120);

    if (respSeqIdx.length === currentSeqIdx.length){
      accepting = false;
      setLamp(false);
      void scoreAndAdvance();
    }
  }

  // =============================
  // Lógica span (como en el artículo: si acierta ≥1 de la misma longitud, sube)
  // :contentReference[oaicite:13]{index=13}
  // =============================
  async function scoreAndAdvance(){
    const ok = arraysEqual(respSeqIdx, currentSeqIdx);
    if (ok){
      totalCorrect += 1;
      correctThisLen += 1;
      bestSpan = Math.max(bestSpan, curLen);
    }

    setStatus();

    await sleep(ITI_AFTER_RESPONSE_MS);

    trialInLen += 1;

    if (trialInLen < TRIALS_PER_LEN){
      await nextTrial();
      return;
    }

    // fin longitud
    if (correctThisLen >= 1){
      curLen += 1;
      trialInLen = 0;
      correctThisLen = 0;

      if (curLen > MAX_LEN){
        finish();
      } else {
        await nextTrial();
      }
    } else {
      finish();
    }
  }

  function getFixedSeq(len, which){
    // which: 0 o 1
    const seqIDs = FIXED_FORWARD[len][which];
    return idsToIdx(seqIDs);
  }

  async function nextTrial(){
    attemptN += 1;
    setStatus();

    // Secuencia fija: para cada longitud, usamos trialInLen (0/1) como selector
    currentSeqIdx = getFixedSeq(curLen, trialInLen);

    await flashSequence(currentSeqIdx);
  }

  function finish(){
    running = false;
    accepting = false;
    setLamp(false);
    btnStart.disabled = false;

    // Solo info final sin secuencias:
    hint.textContent = `FIN. Span = ${bestSpan || 0} | Total aciertos = ${totalCorrect}`;
    setStatus();
  }

  function resetAll(){
    running = false;
    accepting = false;
    setLamp(false);
    btnStart.disabled = false;

    curLen = MIN_LEN;
    trialInLen = 0;
    attemptN = 0;
    currentSeqIdx = [];
    respSeqIdx = [];

    bestSpan = 0;
    totalCorrect = 0;
    correctThisLen = 0;

    clearVisuals();
    hint.textContent = "Toca los bloques en el mismo orden. (No se muestran secuencias.)";
    setStatus();
  }

  async function start(){
    resetAll();
    running = true;
    btnStart.disabled = true;
    await nextTrial();
  }

  // init
  renderBlocks();
  setStatus();

  btnStart.addEventListener('click', () => void start());
  btnReset.addEventListener('click', resetAll);

})();
</script>
</body>
</html>
